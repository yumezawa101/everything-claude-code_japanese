---
name: strategic-compact
description: 任意の自動コンパクションではなく、タスクフェーズ間で context を保持するため、論理的な間隔での手動 context コンパクションを提案します。
---

# 戦略的コンパクションスキル

任意の自動コンパクションに頼るのではなく、ワークフローの戦略的なポイントで手動 `/compact` を提案します。

## なぜ戦略的コンパクションなのか？

自動コンパクションは任意のポイントでトリガーされます：
- タスクの途中で発生することが多く、重要な context が失われる
- 論理的なタスク境界を認識しない
- 複雑な複数ステップの操作を中断する可能性がある

論理的な境界での戦略的コンパクション：
- **探索後、実行前** - リサーチ context をコンパクトにし、実装計画を保持
- **マイルストーン完了後** - 次のフェーズに向けてフレッシュスタート
- **大きな context シフト前** - 異なるタスクの前に探索 context をクリア

## 仕組み

`suggest-compact.sh` スクリプトは PreToolUse（Edit/Write）で実行され、以下を行います：

1. **ツール呼び出しを追跡** - セッション内のツール呼び出し回数をカウント
2. **閾値検出** - 設定可能な閾値（デフォルト：50回）で提案
3. **定期的なリマインダー** - 閾値後25回ごとにリマインド

## Hook 設定

`~/.claude/settings.json` に追加：

```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": "tool == \"Edit\" || tool == \"Write\"",
      "hooks": [{
        "type": "command",
        "command": "~/.claude/skills/strategic-compact/suggest-compact.sh"
      }]
    }]
  }
}
```

## 設定

環境変数：
- `COMPACT_THRESHOLD` - 最初の提案までのツール呼び出し回数（デフォルト：50）

## ベストプラクティス

1. **計画後にコンパクト** - 計画が確定したら、フレッシュスタートのためにコンパクト
2. **デバッグ後にコンパクト** - 継続前にエラー解決の context をクリア
3. **実装中にコンパクトしない** - 関連する変更のために context を保持
4. **提案を読む** - hook は*いつ*を教えてくれ、あなたが*するかどうか*を決める

## 関連

- [The Longform Guide](https://x.com/affaanmustafa/status/2014040193557471352) - トークン最適化セクション
- メモリ永続化 hooks - コンパクションを越えて状態を保持するため
